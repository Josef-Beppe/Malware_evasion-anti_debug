#include <iostream>
#include <Windows.h>

/* Program using several methods to prevent debugging and reverse engineering. */

/* Performs an action when debugging is discovered. */
void response(){
    printf("The program would end here.\n\n");
    //exit(-1);
}

/* Function using simple IsDebuggerPresent() from <Windows.h>. */
int checkDebugger(){
    if(IsDebuggerPresent()){
        printf("checkDebugger: This program is being debugged!\n");
        return 1;
    }
    return 0;
}

/* Implementation of TLS Callback. Runs before main() and avoids some reverse engineering tools. */
void __attribute__ ((constructor)) tlsCallback(){
    if(IsDebuggerPresent()){
        printf("tlsCallback: This program is being debugged!\n");
        response();
    }
}

/* *** The flag-checks only work on 64-bit operating systems, running 64-bit programs. Other possibilities are currently not implemented. The PEB and offsets differ. *** */

/* Function checks the state of NtGlobalFlag located in PEB. It is possible to declare from it, if debugger is being used. */
int checkNtGlobalFlag(){
    PVOID pPeb = (PVOID)__readgsqword(0x0C * sizeof(PVOID));
    DWORD offsetNtGlobalFlag = 0xBC;

    // Locates the actual position of the flag.
    DWORD NtGlobalFlag = *(PDWORD)((PBYTE)pPeb + offsetNtGlobalFlag);

    // Compares the flag with bits corresponding with state, in which a debugger is being used.
    if (NtGlobalFlag & (0x10 | 0x20 | 0x40)){
        printf("checkNtGlobalFlag: This program is being debugged!\n");
        return 1;
    }
    return 0;
}

/* Checks the values of Flags and ForceFlags located on heap. */
int checkHeapFlags(){
    PVOID pPeb = (PVOID)__readgsqword(0x0C * sizeof(PVOID));
    DWORD offsetProcessHeap = 0x30;

    // Places a pointer at the beginning of heap.
    PVOID heap = (PVOID)*(PDWORD_PTR)((PBYTE)pPeb + offsetProcessHeap);

    // Finds the flags. Offsets only work on Windows Vista or higher.
    PDWORD heapFlagsPtr = (PDWORD)((PBYTE)heap + 0x70);
    PDWORD heapForceFlagsPtr = (PDWORD)((PBYTE)heap + 0x74);

    // If the program is being debugged -> Flags does not have the HEAP_GROWABLE flag set, ForceFlags is not zero
    if (*heapFlagsPtr & ~HEAP_GROWABLE || *heapForceFlagsPtr != 0){
        printf("checkHeapFlags: This program is being debugged!\n");
        return 1;
    }
    return 0;
}

/* Checks if a parallel program is not debugging this one. Uses <Windows.h> function. */
int checkRemoteDebugger(){
    BOOL isDebuggerPresent = FALSE;
    if(CheckRemoteDebuggerPresent(GetCurrentProcess(), &isDebuggerPresent)){
        if(isDebuggerPresent){
            printf("checkRemoteDebugger: This program is being debugged!\n");
            return 1;
        }
        return 0;
    }
    printf("ERROR: checkRemoteDebugger: CheckRemoteDebuggerPresent() failed.");
    return -1;
}

/* Raises an exception and observes, if it is caught by the program or by a debugger. */
int checkException(){
    try{
        // It crashes here while debugged, was not really intended but works as an anti-debug.
        throw std::runtime_error("Fail!");
        return 1;
    }
    catch(...){
        return 0;
    }
}

int main()
{
    if(checkDebugger())
        response();
    if(checkNtGlobalFlag())
        response();
    if(checkHeapFlags())
        response();
    if(checkRemoteDebugger())
        response();
    // Works, but crashes the program instead of a controlled response.
    /*if(checkException())
        response();*/

    printf("Finished.\n");
	return 0;
}
